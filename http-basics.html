<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>HTTP Project — HTTP Basics</title>
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header class="site-header">
    <h1>HTTP: A Practical Overview</h1>
    <nav class="main-nav" aria-label="Main">
      <a href="index.html">Home</a>
      <a href="http-basics.html" class="active">HTTP Basics</a>
      <a href="http-performance.html">HTTP Performance</a>
      <a href="key-concepts.html">Key Concepts</a>
      <a href="references.html">References</a>
      <a href="quiz.html">Quiz</a>
      <a href="about.html">About</a>
    </nav>
  </header>

  <div class="container">
    <main id="content">
      <h2>HTTP Basics</h2>

      <p>
        HTTP (Hypertext Transfer Protocol) is how a browser and a web server talk.
        The browser sends a <em>request</em>, and the server sends back a <em>response</em>.
        That’s it! It's a simple idea, and it's used everywhere on the web.
      </p>
      
      <p>
        My View: the request/response model is simple on purpose. It keeps the roles clear.
        The browser asks, the server answers. Once I pictured it like that, reading network
        logs made more sense.
      </p>

      <div class="note">
        <strong>Beginner note:</strong> Think of it like ordering at a counter.
        You say what you want (request). The kitchen brings it back (response).
      </div>

      <h3>Very small example</h3>
      <p>What a basic request and response might look like:</p>

      <pre><code>GET /index.html HTTP/1.1
Host: example.com
User-Agent: MyBrowser
Accept: text/html
</code></pre>

      <pre><code>HTTP/1.1 200 OK
Content-Type: text/html

&lt;!doctype html&gt;
&lt;html&gt;...page content...&lt;/html&gt;
</code></pre>

      <h3>What to remember</h3>
      <ul>
        <li>Requests have a method (like <code>GET</code> or <code>POST</code>) and headers.</li>
        <li>Responses have a status code (200 OK, 404 Not Found, etc.) and headers.</li>
        <li>The body is the actual content (HTML, CSS, images, JSON, and so on).</li>
      </ul>

      <!-- How HTTP works (added for milestone 2) -->
<section id="how-http-works">
  <h2>How HTTP Works</h2>
  <p>
    HTTP is an application-layer protocol for requests and responses between a
    client (browser) and a server. A client asks for a resource identified by a
    URL; the server replies with a status code, headers (metadata), and an
    optional body (HTML, CSS, JS, JSON, images, etc.).
  </p>
  <ul>
    <li><strong>Methods:</strong> GET, POST, PUT, DELETE, …</li>
    <li><strong>Status codes:</strong> 200 OK, 404 Not Found, 500 Server Error, …</li>
    <li><strong>Headers:</strong> content type, language, caching hints, auth data</li>
    <li><strong>Stateless:</strong> requests don’t remember previous ones; “state”
        is added with cookies or other mechanisms.</li>
    <li><strong>Transport-agnostic:</strong> the same HTTP semantics can run over
        TCP (HTTP/1.1, HTTP/2) or QUIC (HTTP/3).</li>
  </ul>
</section>

<!-- A tiny history and the 2022 rewrite (added for milestone 2) -->
<section id="http-history">
  <h2>Brief History</h2>
  <p>
    Early HTTP used a very small “0.9” format, then HTTP/1.0 and 1.1 became the
    common versions. In 2022 the standards were reorganized into clear “core”
    docs: <em>semantics</em>, <em>caching</em>, and protocol mappings for each
    version. That cleanup removed legacy behavior and clarified how the modern
    web uses HTTP.
  </p>
</section>

      <!-- Core semantics (added for milestone 2) -->
<section id="core-semantics">
  <h2>Core HTTP Semantics (Quick Ref)</h2>
  <ul>
    <li><strong>Methods:</strong> GET (read), POST (create), PUT/PATCH (update), DELETE (remove).</li>
    <li><strong>Status codes:</strong> 2xx = success, 3xx = redirect, 4xx = client error, 5xx = server error.</li>
    <li><strong>Headers:</strong> common ones you’ll see are <code>Content-Type</code>, <code>Accept</code>, <code>Cache-Control</code>, <code>Authorization</code>.</li>
    <li><strong>Stateless by design:</strong> each request stands alone; “state” is added with cookies or similar features when needed.</li>
    <li><strong>Same semantics, different transports:</strong> the rules above are the same whether you use HTTP/1.1, HTTP/2, or HTTP/3.</li>
  </ul>

  <p>
    In 2022, the “core” specs were rewritten and split into multiple documents (semantics, caching, and per-version
    mappings). This cleaned up old behavior and clarified how HTTP evolves without breaking the core ideas.
  </p>
  <!-- Sources for this RFC 9110 (Semantics), RFC 9111 (Caching), and the per-version mappings -->
</section>
    </main>

    <footer class="site-footer">
      <p class="note">
        This is a class project for IT 3203. Course link:
        <a href="https://ksuweb.github.io/IT3203/">ksuweb.github.io/IT3203/</a>
      </p>
    </footer>
  </div>
</body>
</html>
